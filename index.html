<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Mobile</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --block-size: 25px;
            --board-width: 10;
            --board-height: 20;
            --game-bg: #111827;
            --grid-border: #374151;
        }
        
        body {
            touch-action: manipulation;
            overscroll-behavior: contain;
            background-color: var(--game-bg);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            user-select: none;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            max-height: 100vh;
        }
        
        .game-header {
            padding: 10px;
            color: white;
        }
        
        .game-area {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            flex: 1;
            overflow: hidden;
            padding: 10px;
        }
        
        #board {
            border: 2px solid #6366F1;
            background-color: var(--game-bg);
            display: grid;
            width: calc(var(--block-size) * var(--board-width));
            height: calc(var(--block-size) * var(--board-height));
            grid-template-columns: repeat(var(--board-width), 1fr);
            grid-template-rows: repeat(var(--board-height), 1fr);
            gap: 1px;
            position: relative;
        }
        
        .cell {
            width: var(--block-size);
            height: var(--block-size);
            border: 1px solid var(--grid-border);
        }
        
        .tetromino {
            border: 1px solid rgba(255, 255, 255, 0.8);
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 500px;
            margin-top: 15px;
        }
        
        .btn-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .btn {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 60px;
            height: 60px;
            background: rgba(99, 102, 241, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            touch-action: manipulation;
            border: none;
            outline: none;
        }
        
        .btn:active {
            background: rgba(99, 102, 241, 1);
            transform: scale(0.95);
        }
        
        .rotate-btn {
            background: rgba(139, 92, 246, 0.8);
        }
        
        .rotate-btn:active {
            background: rgba(139, 92, 246, 1);
        }
        
        .drop-btn {
            background: rgba(239, 68, 68, 0.8);
            width: 80px;
        }
        
        .drop-btn:active {
            background: rgba(239, 68, 68, 1);
        }
        
        .side-btn {
            width: 80px;
        }
        
        .pause-play {
            background: rgba(16, 185, 129, 0.8);
        }
        
        .pause-play:active {
            background: rgba(16, 185, 129, 1);
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        #pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        /* Block colors */
        .i-block { background-color: #00ffff; }
        .j-block { background-color: #0000ff; }
        .l-block { background-color: #ff7f00; }
        .o-block { background-color: #ffff00; }
        .s-block { background-color: #00ff00; }
        .t-block { background-color: #800080; }
        .z-block { background-color: #ff0000; }
        
        /* Portrait orientation */
        @media screen and (max-aspect-ratio: 1/1) {
            :root {
                --block-size: min(4.5vw, 23px);
            }
            
            .controls {
                margin-top: 10px;
            }
            
            .btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            .side-btn {
                width: 65px;
            }
            
            .drop-btn {
                width: 65px;
            }
        }
        
        /* Landscape orientation */
        @media screen and (min-aspect-ratio: 1/1) {
            :root {
                --block-size: min(3vh, 25px);
            }
            
            .game-container {
                flex-direction: row;
            }
            
            .game-area {
                flex-direction: row;
                gap: 20px;
            }
            
            .controls {
                max-width: 300px;
                margin-top: 0;
                margin-left: 10px;
            }
            
            .btn {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
            
            .side-btn {
                width: 60px;
            }
            
            .drop-btn {
                width: 60px;
            }
        }
    </style>
</head>
<body class="bg-gray-900">
    <div class="game-container">
        <div class="game-header">
            <div class="flex justify-between items-center">
                <div class="text-white text-xl font-bold">Tetris</div>
                <div class="flex space-x-4">
                    <div class="text-center">
                        <div class="text-indigo-400 text-sm">Score</div>
                        <div id="score" class="text-white text-lg font-bold">0</div>
                    </div>
                    <div class="text-center">
                        <div class="text-indigo-400 text-sm">Level</div>
                        <div id="level" class="text-white text-lg font-bold">1</div>
                    </div>
                    <div class="text-center">
                        <div class="text-indigo-400 text-sm">Lines</div>
                        <div id="lines" class="text-white text-lg font-bold">0</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="game-area">
            <div id="board-container">
                <div id="board"></div>
                
                <div id="pause-screen" class="text-white text-center">
                    <h2 class="text-3xl font-bold mb-4">PAUSED</h2>
                    <p class="mb-4">Tap play to continue</p>
                </div>
                
                <div id="game-over" class="text-white text-center">
                    <h2 class="text-3xl font-bold mb-4">GAME OVER</h2>
                    <p class="mb-2">Final Score: <span id="final-score">0</span></p>
                    <button id="restart" class="bg-indigo-600 text-white px-4 py-2 rounded mt-4 hover:bg-indigo-700">
                        Play Again
                    </button>
                </div>
            </div>
            
            <div class="controls">
                <div class="btn-row justify-center mb-2">
                    <button class="btn drop-btn" id="hard-drop">
                        <i class="fas fa-angle-double-down"></i>
                    </button>
                </div>
                
                <div class="btn-row">
                    <button class="btn side-btn" id="left">
                        <i class="fas fa-angle-left"></i>
                    </button>
                    <button class="btn" id="rotate">
                        <i class="fas fa-redo-alt"></i>
                    </button>
                    <button class="btn side-btn" id="right">
                        <i class="fas fa-angle-right"></i>
                    </button>
                </div>
                
                <div class="btn-row">
                    <button class="btn pause-play" id="pause-play">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="btn rotate-btn" id="rotate-counter">
                        <i class="fas fa-undo-alt"></i>
                    </button>
                    <button class="btn" id="soft-drop">
                        <i class="fas fa-angle-down"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game configuration
            const boardWidth = 10;
            const boardHeight = 20;
            const initialSpeed = 1000; // ms between automatic drops
            
            // Game state
            let board = Array(boardHeight).fill().map(() => Array(boardWidth).fill(0));
            let currentPiece = null;
            let currentPosition = { x: 0, y: 0 };
            let score = 0;
            let level = 1;
            let lines = 0;
            let gameInterval = null;
            let isPaused = false;
            let isGameOver = false;
            let dropSpeed = initialSpeed;
            let touchStartX = 0;
            let touchStartY = 0;
            const swipeThreshold = 30;
            
            // Audio elements
            const moveSound = new Audio();
            moveSound.src = 'data:audio/mpeg;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFzb25pY1N0dWRpb3MuY29tAFRYWFgAAAASAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAUAAAiSAAODhMTGBgYHh4jIygoKC4uMzM4ODg+Pj09PUNDSEhISE1NUlJSUldXXFxcXGJiZ2dnZ2xsc3Nzc3h4fX19fYODiIiIiI6Ok5OTk5iYnZ2dnZ2jo6ioqKiurre3t7e9vcLCwsLIyM3Nzc3S0tfX19fd3eLi4uLo6O3t7e3y8vf39/f8/AAARkxBTUUzLjEwMAqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBkQg/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBkig/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBksg/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBk2g/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBk/A/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBlBA/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBkFg/wAABpAAAACAAADSAAAAEAAAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==';
            moveSound.load();
            
            const rotateSound = new Audio();
            rotateSound.src = 'data:audio/mpeg;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFzb25pY1N0dWRpb3MuY29tAFRYWFgAAAASAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAGAAAGmwAdHR0dJCQkJCQrKysrMjIyMjI5OTk5QUFBQUE5OTk5MjIyMjIrKysrJCQkJB0dHR0dAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/7EGQAD/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZEIP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZIoP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZLIP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZNIP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZOoP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZQIP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZRgP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';
            rotateSound.load();
            
            const lineSound = new Audio();
            lineSound.src = 'data:audio/mpeg;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFzb25pY1N0dWRpb3MuY29tAFRYWFgAAAASAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAtAAAZSAAHDw8XHx8nJy8vNz8/R0dPT1dXX19nZ29vd3d/f4eHj4+Xl5+fp6evr7e3v7/Hx8/P19ff3+fn7+/39wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+xBkAA/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAAQxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZCYP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZEgP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZGoP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZIwP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZK4P8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZNAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZPIP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZRQP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';
            lineSound.load();
            
            const gameOverSound = new Audio();
            gameOverSound.src = 'data:audio/mpeg;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFzb25pY1N0dWRpb3MuY29tAFRYWFgAAAASAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAkAAAkoAADAwMJCQkPDw8VFRUbGxshISEnJyctLS0zMzM5OTk/Pz9FRUVLSUtLS0tRUVFRV1dXV11dXV1jY2NjZ2dnZ21tbW1zc3Nze3t7e4GBgYGHh4eHjY2NjZOTk5OZmZmZn5+fn6Wlpaerq6ursLCwsLa2tra8vLy8wsLCwsjIyMjOzs7O1NTU1Nra2trg4ODg5ubm5uzs7Ozy8vLy+Pj4+P8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBkIA/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBkSg/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBkdA/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBkng/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBkyA/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBk8g/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBlHA/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+xBlRg/wAABpAAAACAAADSAAAAEAAAGkAAAAIAAANIAAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==';
            gameOverSound.load();

            // Tetrominos shapes and colors
            const tetrominoes = {
                I: {
                    shape: [
                        [0, 0, 0, 0],
                        [1, 1, 1, 1],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]
                    ],
                    color: 'i-block'
                },
                J: {
                    shape: [
                        [1, 0, 0],
                        [1, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 'j-block'
                },
                L: {
                    shape: [
                        [0, 0, 1],
                        [1, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 'l-block'
                },
                O: {
                    shape: [
                        [1, 1],
                        [1, 1]
                    ],
                    color: 'o-block'
                },
                S: {
                    shape: [
                        [0, 1, 1],
                        [1, 1, 0],
                        [0, 0, 0]
                    ],
                    color: 's-block'
                },
                T: {
                    shape: [
                        [0, 1, 0],
                        [1, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 't-block'
                },
                Z: {
                    shape: [
                        [1, 1, 0],
                        [0, 1, 1],
                        [0, 0, 0]
                    ],
                    color: 'z-block'
                }
            };
            
            // Initialize the game board
            function initBoard() {
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = '';
                
                // Create the grid
                for (let y = 0; y < boardHeight; y++) {
                    for (let x = 0; x < boardWidth; x++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        boardEl.appendChild(cell);
                    }
                }
            }
            
            // Get a random tetromino
            function getRandomTetromino() {
                const keys = Object.keys(tetrominoes);
                const randIndex = Math.floor(Math.random() * keys.length);
                const key = keys[randIndex];
                return {
                    shape: tetrominoes[key].shape,
                    color: tetrominoes[key].color,
                    type: key
                };
            }
            
            // Create a new piece
            function createNewPiece() {
                currentPiece = getRandomTetromino();
                currentPosition = {
                    x: Math.floor((boardWidth - currentPiece.shape[0].length) / 2),
                    y: 0
                };
                
                // Check for collision (game over)
                if (checkCollision(currentPosition.x, currentPosition.y, currentPiece.shape)) {
                    gameOver();
                    return false;
                }
                
                return true;
            }
            
            // Draw the current piece on the board
            function drawPiece() {
                clearPiece();
                if (!currentPiece) return;
                
                const shape = currentPiece.shape;
                const color = currentPiece.color;
                
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x] !== 0) {
                            const boardX = currentPosition.x + x;
                            const boardY = currentPosition.y + y;
                            
                            // Only draw if in bounds
                            if (boardY >= 0 && boardY < boardHeight && boardX >= 0 && boardX < boardWidth) {
                                const cell = document.querySelector(`.cell[data-x="${boardX}"][data-y="${boardY}"]`);
                                if (cell) {
                                    cell.classList.add('tetromino', color);
                                }
                            }
                        }
                    }
                }
            }
            
            // Clear the current piece from the board (visual only)
            function clearPiece() {
                const cells = document.querySelectorAll('.cell.tetromino');
                cells.forEach(cell => {
                    cell.classList.remove('tetromino', 'i-block', 'j-block', 'l-block', 'o-block', 's-block', 't-block', 'z-block');
                });
            }
            
            // Check for collisions
            function checkCollision(x, y, shape) {
                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col] !== 0) {
                            const boardX = x + col;
                            const boardY = y + row;
                            
                            // Check if out of bounds
                            if (boardX < 0 || boardX >= boardWidth || boardY >= boardHeight) {
                                return true;
                            }
                            
                            // Check if already filled
                            if (boardY >= 0 && board[boardY][boardX] !== 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            // Move the current piece
            function movePiece(dx, dy) {
                if (isGameOver || isPaused) return false;
                
                const newX = currentPosition.x + dx;
                const newY = currentPosition.y + dy;
                
                if (!checkCollision(newX, newY, currentPiece.shape)) {
                    currentPosition.x = newX;
                    currentPosition.y = newY;
                    drawPiece();
                    return true;
                }
                
                // If we couldn't move down, lock the piece
                if (dy > 0) {
                    lockPiece();
                    return false;
                }
                
                return false;
            }
            
            // Rotate the current piece
            function rotatePiece(counterClockwise = false) {
                if (isGameOver || isPaused) return;
                
                // Clone the current shape
                const currentShape = currentPiece.shape;
                const length = currentShape.length;
                
                // Create a new rotated shape
                let newShape = Array.from({ length }, () => Array(length).fill(0));
                
                if (counterClockwise) {
                    // Rotate counter-clockwise
                    for (let y = 0; y < length; y++) {
                        for (let x = 0; x < length; x++) {
                            newShape[length - 1 - x][y] = currentShape[y][x];
                        }
                    }
                } else {
                    // Rotate clockwise
                    for (let y = 0; y < length; y++) {
                        for (let x = 0; x < length; x++) {
                            newShape[x][length - 1 - y] = currentShape[y][x];
                        }
                    }
                }
                
                // Check if rotation is possible
                if (!checkCollision(currentPosition.x, currentPosition.y, newShape)) {
                    rotateSound.currentTime = 0;
                    rotateSound.play().catch(e => console.error("Audio play failed:", e));
                    currentPiece.shape = newShape;
                    drawPiece();
                } else {
                    // Try wall kick - move piece around to make space for rotation
                    const kicks = [
                        { x: 1, y: 0 },  // right
                        { x: -1, y: 0 }, // left
                        { x: 0, y: -1 }, // up
                        { x: 2, y: 0 },  // 2 spaces right
                        { x: -2, y: 0 }  // 2 spaces left
                    ];
                    
                    for (const kick of kicks) {
                        if (!checkCollision(currentPosition.x + kick.x, currentPosition.y + kick.y, newShape)) {
                            currentPosition.x += kick.x;
                            currentPosition.y += kick.y;
                            currentPiece.shape = newShape;
                            rotateSound.currentTime = 0;
                            rotateSound.play().catch(e => console.error("Audio play failed:", e));
                            drawPiece();
                            return;
                        }
                    }
                }
            }
            
            // Lock the current piece into the board
            function lockPiece() {
                const shape = currentPiece.shape;
                const color = currentPiece.type;
                
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x] !== 0) {
                            const boardX = currentPosition.x + x;
                            const boardY = currentPosition.y + y;
                            
                            if (boardY >= 0 && boardY < boardHeight && boardX >= 0 && boardX < boardWidth) {
                                board[boardY][boardX] = color;
                                
                                // Update the appearance of the locked cell
                                const cell = document.querySelector(`.cell[data-x="${boardX}"][data-y="${boardY}"]`);
                                if (cell) {
                                    cell.classList.remove('tetromino');
                                    cell.classList.add(currentPiece.color);
                                }
                            }
                        }
                    }
                }
                
                clearLines();
                createNewPiece();
            }
            
            // Check and clear completed lines
            function clearLines() {
                let linesCleared = 0;
                
                for (let y = boardHeight - 1; y >= 0; y--) {
                    const isLineComplete = board[y].every(cell => cell !== 0);
                    
                    if (isLineComplete) {
                        linesCleared++;
                        // Move all rows above down one
                        for (let yy = y; yy > 0; yy--) {
                            for (let x = 0; x < boardWidth; x++) {
                                board[yy][x] = board[yy - 1][x];
                            }
                        }
                        
                        // Clear top row
                        board[0] = Array(boardWidth).fill(0);
                        
                        // Instead of recursing, increment y to check the same row again
                        y++; 
                    }
                }
                
                if (linesCleared > 0) {
                    lineSound.currentTime = 0;
                    lineSound.play().catch(e => console.error("Audio play failed:", e));
                    
                    updateScore(linesCleared);
                    updateBoard();
                }
            }
            
            // Update the visual board to match the data structure
            function updateBoard() {
                for (let y = 0; y < boardHeight; y++) {
                    for (let x = 0; x < boardWidth; x++) {
                        const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
                        if (cell) {
                            // Clear all class styles first
                            cell.classList.remove('tetromino', 'i-block', 'j-block', 'l-block', 'o-block', 's-block', 't-block', 'z-block');
                            
                            // Apply the appropriate style based on board data
                            if (board[y][x] !== 0) {
                                cell.classList.add(tetrominoes[board[y][x]].color);
                            }
                        }
                    }
                }
            }
            
            // Update the score
            function updateScore(linesCleared) {
                // Different points for different number of lines cleared
                const linePoints = [0, 100, 300, 500, 800]; // 0, 1, 2, 3, 4 lines
                score += linePoints[linesCleared] * level;
                lines += linesCleared;
                
                // Update level every 10 lines
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    // Make the game faster
                    dropSpeed = Math.max(100, initialSpeed - (level - 1) * 100);
                    
                    if (gameInterval) {
                        clearInterval(gameInterval);
                        gameInterval = setInterval(tick, dropSpeed);
                    }
                }
                
                // Update the UI
                document.getElementById('score').textContent = score;
                document.getElementById('level').textContent = level;
                document.getElementById('lines').textContent = lines;
            }
            
            // Hard drop the piece (drop all the way down)
            function hardDrop() {
                if (isGameOver || isPaused) return;
                
                let droppedRows = 0;
                while (movePiece(0, 1)) {
                    droppedRows++;
                }
                
                // Add points for hard drop
                if (droppedRows > 0) {
                    score += droppedRows * 2;
                    document.getElementById('score').textContent = score;
                }
            }
            
            // Game over
            function gameOver() {
                isGameOver = true;
                gameOverSound.play().catch(e => console.error("Audio play failed:", e));
                
                if (gameInterval) {
                    clearInterval(gameInterval);
                    gameInterval = null;
                }
                
                document.getElementById('final-score').textContent = score;
                document.getElementById('game-over').style.display = 'flex';
            }
            
            // Toggle pause/play
            function togglePause() {
                const pausePlayBtn = document.getElementById('pause-play');
                const pauseScreen = document.getElementById('pause-screen');
                
                if (isGameOver) return;
                
                isPaused = !isPaused;
                
                if (isPaused) {
                    clearInterval(gameInterval);
                    gameInterval = null;
                    pausePlayBtn.innerHTML = '<i class="fas fa-play"></i>';
                    pauseScreen.style.display = 'flex';
                } else {
                    gameInterval = setInterval(tick, dropSpeed);
                    pausePlayBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    pauseScreen.style.display = 'none';
                }
            }
            
            // Start a new game
            function startGame() {
                // Reset game state
                isGameOver = false;
                isPaused = false;
                score = 0;
                level = 1;
                lines = 0;
                dropSpeed = initialSpeed;
                board = Array(boardHeight).fill().map(() => Array(boardWidth).fill(0));
                
                // Update UI
                document.getElementById('score').textContent = score;
                document.getElementById('level').textContent = level;
                document.getElementById('lines').textContent = lines;
                document.getElementById('game-over').style.display = 'none';
                document.getElementById('pause-screen').style.display = 'none';
                document.getElementById('pause-play').innerHTML = '<i class="fas fa-pause"></i>';
                
                // Reset the board
                initBoard();
                
                // Create first piece
                createNewPiece();
                drawPiece();
                
                // Start the game loop
                if (gameInterval) {
                    clearInterval(gameInterval);
                }
                gameInterval = setInterval(tick, dropSpeed);
            }
            
            // Game tick - called on each interval
            function tick() {
                if (isGameOver || isPaused) return;
                movePiece(0, 1);
            }
            
            // Button controls
            function setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (isGameOver) return;
                    
                    switch (e.key) {
                        case 'ArrowLeft':
                            movePiece(-1, 0);
                            moveSound.currentTime = 0;
                            moveSound.play().catch(err => {});
                            break;
                        case 'ArrowRight':
                            movePiece(1, 0);
                            moveSound.currentTime = 0;
                            moveSound.play().catch(err => {});
                            break;
                        case 'ArrowDown':
                            movePiece(0, 1);
                            break;
                        case 'ArrowUp':
                            rotatePiece();
                            break;
                        case ' ':
                            hardDrop();
                            break;
                        case 'z':
                        case 'Z':
                            rotatePiece(true);
                            break;
                        case 'p':
                        case 'P':
                            togglePause();
                            break;
                        default:
                            break;
                    }
                });
                
                // Touch button controls
                document.getElementById('left').addEventListener('click', () => {
                    movePiece(-1, 0);
                    moveSound.currentTime = 0;
                    moveSound.play().catch(err => {});
                });
                
                document.getElementById('right').addEventListener('click', () => {
                    movePiece(1, 0);
                    moveSound.currentTime = 0;
                    moveSound.play().catch(err => {});
                });
                
                document.getElementById('soft-drop').addEventListener('click', () => {
                    movePiece(0, 1);
                });
                
                document.getElementById('hard-drop').addEventListener('click', () => {
                    hardDrop();
                });
                
                document.getElementById('rotate').addEventListener('click', () => {
                    rotatePiece();
                });
                
                document.getElementById('rotate-counter').addEventListener('click', () => {
                    rotatePiece(true);
                });
                
                document.getElementById('pause-play').addEventListener('click', () => {
                    togglePause();
                });
                
                document.getElementById('restart').addEventListener('click', () => {
                    startGame();
                });
                
                // Touch events for swipe controls
                const boardEl = document.getElementById('board');
                
                boardEl.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }, { passive: true });
                
                boardEl.addEventListener('touchmove', (e) => {
                    if (isGameOver || isPaused) return;
                    e.preventDefault(); // Prevent scrolling
                }, { passive: false });
                
                boardEl.addEventListener('touchend', (e) => {
                    if (isGameOver || isPaused) return;
                    
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    
                    const diffX = touchEndX - touchStartX;
                    const diffY = touchEndY - touchStartY;
                    
                    if (Math.abs(diffX) > swipeThreshold && Math.abs(diffY) < swipeThreshold) {
                        // Horizontal swipe
                        if (diffX > 0) {
                            movePiece(1, 0); // Right
                            moveSound.currentTime = 0;
                            moveSound.play().catch(err => {});
                        } else {
                            movePiece(-1, 0); // Left
                            moveSound.currentTime = 0;
                            moveSound.play().catch(err => {});
                        }
                    } else if (Math.abs(diffY) > swipeThreshold && Math.abs(diffX) < swipeThreshold) {
                        // Vertical swipe
                        if (diffY > 0) {
                            hardDrop(); // Down
                        } else {
                            rotatePiece(); // Up
                        }
                    }
                }, { passive: true });
                
                // Double tap to rotate
                let lastTap = 0;
                boardEl.addEventListener('touchend', (e) => {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    if (tapLength < 300 && tapLength > 0) {
                        rotatePiece();
                        e.preventDefault();
                    }
                    lastTap = currentTime;
                }, { passive: true });
            }
            
            // Fix for iOS Safari 100vh issue
            function fixIOSViewportHeight() {
                const viewportHeight = () => {
                    document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
                };
                
                window.addEventListener('resize', viewportHeight);
                window.addEventListener('orientationchange', viewportHeight);
                viewportHeight();
            }
            
            // Initialize the game
            function init() {
                fixIOSViewportHeight();
                initBoard();
                setupControls();
                startGame();
                
                // Prevent context menu on touch devices
                document.addEventListener('contextmenu', e => e.preventDefault());
            }
            
            // Start the game when page loads
            init();
        });
    </script>
</body>
</html>
